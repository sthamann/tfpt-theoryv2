#####################################################################
#       This file was automatically generated by PyR@TE 3.
# It contains the expressions of the RGEs of the model 'SM_TFPT_2Loop_v25'.
#####################################################################

import numpy as np

tr = lambda x: np.trace(x)
adjoint = lambda x: x.H
transpose = lambda x: x.transpose()
conjugate = lambda x: np.conjugate(x)


###################
# Gauge Couplings #
###################

def beta_g1(nLoop, g1):
    if nLoop == 1:
        return (41/6)*g1**3

def beta_g2(nLoop, g2):
    if nLoop == 1:
        return -19/6*g2**3

def beta_g3(nLoop, g3):
    if nLoop == 1:
        return -7*g3**3


####################
# Yukawa Couplings #
####################

def beta_Yu(nLoop, g1,g2,g3,Yu,Yd,Ye):
    if nLoop == 1:
        return -17/12*g1**2*Yu - 9/4*g2**2*Yu - 8*g3**2*Yu + 3*tr(adjoint(Yd)*Yd)*Yu + tr(adjoint(Ye)*Ye)*Yu + 3*tr(adjoint(Yu)*Yu)*Yu - 3/2*Yd*adjoint(Yd)*Yu + (3/2)*Yu*adjoint(Yu)*Yu

def beta_Yd(nLoop, g1,g2,g3,Yu,Yd,Ye):
    if nLoop == 1:
        return -5/12*g1**2*Yd - 9/4*g2**2*Yd - 8*g3**2*Yd + 3*tr(adjoint(Yd)*Yd)*Yd + tr(adjoint(Ye)*Ye)*Yd + 3*tr(adjoint(Yu)*Yu)*Yd + (3/2)*Yd*adjoint(Yd)*Yd - 3/2*Yu*adjoint(Yu)*Yd

def beta_Ye(nLoop, g1,g2,Yu,Yd,Ye):
    if nLoop == 1:
        return -15/4*g1**2*Ye - 9/4*g2**2*Ye + 3*tr(adjoint(Yd)*Yd)*Ye + tr(adjoint(Ye)*Ye)*Ye + 3*tr(adjoint(Yu)*Yu)*Ye + (3/2)*Ye*adjoint(Ye)*Ye


#####################
# Quartic Couplings #
#####################

def beta_lambda_(nLoop, g1,g2,Yu,Yd,Ye,lambda_):
    if nLoop == 1:
        return (3/8)*g1**4 + (3/4)*g1**2*g2**2 - 3*g1**2*lambda_ + (9/8)*g2**4 - 9*g2**2*lambda_ + 24*lambda_**2 + 12*lambda_*tr(adjoint(Yd)*Yd) + 4*lambda_*tr(adjoint(Ye)*Ye) + 12*lambda_*tr(adjoint(Yu)*Yu) - 6*tr(adjoint(Yd)*Yd*adjoint(Yd)*Yd) - 2*tr(adjoint(Ye)*Ye*adjoint(Ye)*Ye) - 6*tr(adjoint(Yu)*Yu*adjoint(Yu)*Yu)


#########################
# Scalar Mass Couplings #
#########################

def beta_mu2(nLoop, g1,g2,Yu,Yd,Ye,lambda_,mu2):
    if nLoop == 1:
        return -3/2*g1**2*mu2 - 9/2*g2**2*mu2 + 12*lambda_*mu2 + 6*mu2*tr(adjoint(Yd)*Yd) + 2*mu2*tr(adjoint(Ye)*Ye) + 6*mu2*tr(adjoint(Yu)*Yu)


#############################
# Vacuum-expectation Values #
#############################

def beta_vSM(nLoop, g1,g2,Yu,Yd,Ye,vSM,xiGauge):
    if nLoop == 1:
        return (1/4)*xiGauge*g1**2*vSM + (3/4)*xiGauge*g2**2*vSM + (3/4)*g1**2*vSM + (9/4)*g2**2*vSM - 3*vSM*tr(adjoint(Yd)*Yd) - vSM*tr(adjoint(Ye)*Ye) - 3*vSM*tr(adjoint(Yu)*Yu)